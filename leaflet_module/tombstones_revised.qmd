---
title: "Leaflet_tester"
date: 06-30-2023
categories: [Data-Viz, openxlsx, stringr, fuzzyjoin, mapview, sf] # self-defined categories
draft: true # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
---

This is a draft of a project for my father. I want to make sure the photo files structure renders properly online. This will be revised and reposted later as a tutorial. It will also be deleted once I get his input.

```{r}
library(tidyverse) # who doesn't want to be tidy?
library(ggthemes) # more themes for ggplot
library(gt) # For nice tables
library(ggrepel) # to help position labels in ggplot graphs
library(openxlsx) # importing excel files from a URL
library(fuzzyjoin) # for joining on inexact matches
library(sf) # for handling geo data

library(leaflet) # more mapping
library(here)
library(magick)
library(skimr)

```

Reading in his spreadsheet

```{r}
blog_folder <- "leaflet_module"
photo_folder <- "Photos"
archive_folder <- "Archived Photos"
unmatched_folder <- "Unmatched Photos"
match1 <- "Matched_Round1"
match2 <- "Matched_Round2"
match3 <- "Matched_Round3"
match4 <- "Matched_Round4"
#data_file <- "Tombstone_Data_small.xlsx"
data_file <- "Tombstone Data.xlsx"
# read in excel sheet
tombstones_raw <-
  read.xlsx(here(blog_folder, data_file),
    sheet = 1
  )

```

Overview

# Fixing GPS

Latitude and longitude data contains some stray degree and minute symbols. The degree symbol appears both as a straight and curved apostrophe and the degree symbols appear both as o and O. This cleaning needs to be done on both N and W columns.

```{r}

tombstones <- tombstones_raw %>%
mutate(N = str_replace_all(N, pattern = "’", " ")) %>%
mutate(N = str_replace_all(N, pattern = "O", " "))  %>%
mutate(N = str_replace_all(N, pattern = "o", " "))  %>%
mutate(N = str_replace_all(N, pattern = "'", " "))  %>% 
mutate(W = str_replace_all(W, pattern = "’", " ")) %>%
mutate(W = str_replace_all(W, pattern = "O", " "))  %>% 
mutate(W = str_replace_all(W, pattern = "o", " ")) %>%
mutate(W = str_replace_all(W, pattern = "'", " ")) 



```

Next, I'm converting the N and W data to decimal latitude and longitude. S/W should be "-" and N/E should be "+". I split the degree/minute/second data into parts and then do the conversion. I delete the intermediate components when done.

```{r}
#converting to decimal latitude
tombstones <- tombstones %>%
  mutate(part1N = str_split_fixed(N, pattern = " ", n = 2) ) %>%
  mutate(N_degree = as.numeric(part1N[,1])) %>%
  mutate(part2N = str_split_fixed(part1N[,2], pattern = '\\.', n = 2)) %>%
  mutate(N_minute = as.numeric(part2N[,1])) %>%
  mutate(N_second = as.numeric(part2N[,2])) %>%
  mutate(lat = N_degree + N_minute/60 + N_second/3600)

#converting to decimal longitude  
tombstones <- tombstones %>%
  mutate(part1W = str_split_fixed(W, pattern = " ", n = 2) ) %>%
  mutate(W_degree = as.numeric(part1W[,1])) %>%
  mutate(part2W = str_split_fixed(part1W[,2], pattern = '\\.', n = 2)) %>%
  mutate(W_minute = as.numeric(part2W[,1])) %>%
  mutate(W_second = as.numeric(part2W[,2])) %>%
  mutate(long = -(W_degree + W_minute/60 + W_second/3600)) 

tombstones <- tombstones %>%
  select(-contains("part"))


```
# Cleaning up dates

```{r}
# library(lubridate)
# tombstones2 <- tombstones %>%
#   mutate(DOB_date = ifelse(is.na(DOB) == FALSE, as.Date(DOB, format = "%d %b %Y"), NA))
```

just apply to everything

```{r}
tombstones <- tombstones %>%
  mutate(DOB_date = as.Date(DOB, format = "%d %b %Y")) %>%
  mutate(DOD_date = as.Date(DOD, format = "%d %b %Y"))


```

Saving for use in rvest

```{r}
saveRDS(tombstones, "tombstones_cleaned.RDS")
```



# Cleaning Up Cemetery data

Let's look at the cemetery data. spaces

```{r}
tombstones <- tombstones %>%
#mutate(Middle.Name = ifelse(is.na(Middle.Name), "", Middle.Name)) %>%
  mutate(Cemetery = ifelse(is.na(Cemetery), "", Cemetery))


```

## Code for looking at the cemetery data

```{r}
#cems <- tombstones %>% group_by(Cemetery) %>% count(sort = TRUE)
```

Let's look at how many unique cemetery names there are. This will help with typos.

```{r}
#cems_unique <- tombstones %>% distinct(Cemetery)
```

# Cleaning Up Names

My father's photo naming convention is "last name first name middle initial". I'm going to construct a variable full_name from the spreadsheet data and use that to match.

## Cleaning up First Names

This is actually the cleanup code from Middle Name modified

```{r}
tombstones <- tombstones %>%
  mutate(Extra_First_Name = str_extract(First.Name, "\\[.+\\]")) %>%
  mutate(First.Name = str_replace(First.Name, "\\[.+\\]", "")) %>%
  mutate(First.Name = str_replace(First.Name, "\\.", "")) %>%
  mutate(First.Name = str_trim(First.Name, side = c("both"))) %>%
  mutate(First.Name = na_if(First.Name, "")) 
```

## Cleaning up Middle Names

The middle name column is problematic. Sometimes it is the middle name. Sometimes it is a notes like "shared family tombstone". Sometimes it is the middle initial from the gravestone, but with the full name filled in with brackets like A\[lvis\]. Sometimes it is a maiden name or the name of the spouse.

Easy stuff first- stripping out extra spaces and periods and the abreviation ux (latin for wife) and us (a typo for ux). REMEMBER TO ESCAPE PERIODS and brackets

```{r}
tombstones <- tombstones %>%
  mutate(Middle.Name = str_replace(Middle.Name, "ux ", "")) %>%
  mutate(Middle.Name = str_replace(Middle.Name, "us ", "")) %>%
  mutate(Extra_Middle_Name = str_extract(Middle.Name, "\\[.+\\]")) %>%
  mutate(Middle.Name = str_replace(Middle.Name, "\\[.+\\]", "")) %>%
  mutate(Middle.Name = str_replace(Middle.Name, "\\.", "")) %>%
  mutate(Middle.Name = str_trim(Middle.Name, side = c("both"))) %>%
  mutate(Middle.Name = na_if(Middle.Name, "")) 
  
  
```

This fixes most of the issues, but not all. I'm going to see how the rest of this going and then come back and fix problem cases. It is possible that the entire middle name should be thrown out if ux is there, but I did see that some photos seem to have spouse names.

```{r}
tombstones <- tombstones %>%
  mutate(full_name_MI = ifelse(
    is.na(Middle.Name) == TRUE,
    Middle.Name,
    paste(Surname, First.Name, Middle.Name, sep = " ")
  )) %>%
  mutate(full_name = paste(Surname, First.Name, sep = " "))
```

After running through the full matching code, I see that for first and middle names that are only letters, sometimes the photo name is sinks le and sometimes it is sinks l e . So I need a second middle name column for these cases. (There are also cases with initials in the middle name itself. I don't know if I need to clean that up. See Hess Ulysses S G)

```{r}
tombstones <- tombstones %>%
  mutate(full_name_MI_no_space = ifelse(
    is.na(Middle.Name) == TRUE,
    Middle.Name,
    paste(Surname, paste0(First.Name, Middle.Name), sep = " ")
  )) 
```

Removing the names that aren't initials and making nas

```{r}
tombstones <- tombstones %>%
  mutate(full_name_MI_no_space = ifelse(
    nchar(paste0(First.Name, Middle.Name)) > 3,
    " ",
    full_name_MI_no_space
  )) %>%
  mutate(full_name_MI_no_space = na_if(full_name_MI_no_space, " "))
```

Now, I'm going to split this into two dataframe.

PEOPLE WHO HAD MIDDLE NAMES removed are not nas!!!!! FIXED ABOVE



# Matching to Photos

## Reset Photo Folders

This moves all the files into the main folder.

**Need to delete files in the folders firs**t

For safety's sake, I'm going to move them instead.

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Unmatched Photos"))
 file.rename(
      from = here(blog_folder, photo_folder,"Unmatched Photos", my_file_list),
      to = here(blog_folder, photo_folder, "Trash", my_file_list))
```

Next folder

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Archived Photos"))
 file.rename(
      from = here(blog_folder, photo_folder,"Archived Photos", my_file_list),
      to = here(blog_folder, photo_folder, "Trash", my_file_list))
```

Next folder

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Matched_Round1"))
 file.rename(
      from = here(blog_folder, photo_folder,"Matched_Round1", my_file_list),
      to = here(blog_folder, photo_folder, "Trash", my_file_list))
```

Next folder

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Matched_Round2"))
 file.rename(
      from = here(blog_folder, photo_folder,"Matched_Round2", my_file_list),
      to = here(blog_folder, photo_folder, "Trash", my_file_list))
```

next folder

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Matched_Round3"))
 file.rename(
      from = here(blog_folder, photo_folder,"Matched_Round3", my_file_list),
      to = here(blog_folder, photo_folder, "Trash", my_file_list))
```

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Matched_Round4"))
 file.rename(
      from = here(blog_folder, photo_folder,"Matched_Round4", my_file_list),
      to = here(blog_folder, photo_folder, "Trash", my_file_list))
```

moving new files in

```{r}
my_file_list <- list.files(here(blog_folder, photo_folder, "Original Photos"))

file.copy(
      from = here(blog_folder, photo_folder, "Original Photos", my_file_list),
      to = here(blog_folder, photo_folder, unmatched_folder, my_file_list)
      )
```

## Matching the folks with Middle Names and Spaces

Create the dataframe of files to match. This goes outside the function

```{r}

tombstones_middle <- tombstones %>%
  filter(is.na(Middle.Name) == FALSE)

```


https://stackoverflow.com/questions/52437463/function-calling-variable-names-for-group-by-in-dplyr-how-do-i-vectorise-this

```{r}
Matching_Photos <-
  function(df_to_match, name_to_match, match_folder) {
    #Step 1: list of unmatched photos
    photo_names = list.files(here(blog_folder, photo_folder, unmatched_folder))
    photo_df = as.data.frame(photo_names)
    #Step 2: generate duplicate names
    duplicate_names <- df_to_match %>%
      group_by_at(name_to_match) %>% count(sort = TRUE) %>% filter(n > 1)
    
   # return(duplicate_names)
    
     #Step 3: remove duplicate names
    tombstones_unique_names <- df_to_match %>%
      anti_join(duplicate_names)
    #step 4: do the matching
    tombstones_merged <-
      fuzzy_right_join(
        photo_df,
        tombstones_unique_names,
        by = c("photo_names" = name_to_match),
        match_fun = str_detect
      )
    #step 5: Moving all the photos that match to the correct match folder
    matched_this_round <- inner_join(photo_df, tombstones_merged)

    index <- 1
    for (index in seq(1:nrow(matched_this_round))) {
      file.rename(
        from = here(
          blog_folder,
          photo_folder,
          unmatched_folder,
          matched_this_round$photo_names[index]
        ),
        to = here(
          blog_folder,
          photo_folder,
          match_folder,
          matched_this_round$photo_names[index]
        )
      )
    }
    #step 6: Remove any unmatched names
    tombstones_merged <- tombstones_merged %>%
    drop_na(photo_names)
 #step 7: generate the list of folks with multiple photos
     multiple_photos <- tombstones_merged %>% group_by_at(name_to_match) %>% count(sort = TRUE) %>% filter(n > 1) 
    #step 8: make the panel photos and move the originals to archive. (function?)
 
    return(multiple_photos)

 }
```

does this part of the function work?
```{r}
tester <- Matching_Photos(tombstones_middle, "full_name_MI", match1)
```




How many people have multiple photos?

```{r}

 #step 7: generate the list of folks with multiple photos
     multiple_photos <- tombstones_merged %>% group_by_at(name_to_match) %>% count(sort = TRUE) %>% filter(n > 1) 
    #step 8: make the panel photos and move the originals to archive. (function?)
     
#testing
if (nrow(multiple_photos) > 0 ) {
index <- 1

for (index in seq(1:nrow(multiple_photos))) {
  df_temp <- tombstones_merged %>%
    filter(full_name_MI == multiple_photos[index, 1])
  df_temp
  these <-
    as.list(here(blog_folder, photo_folder, match1, df_temp$photo_names))
  photo_panel <-
    image_append(do.call("c", lapply(these, image_read)))
  image_write(
    photo_panel,
    path =  here(
      blog_folder,
      photo_folder,
      match_folder,
      paste0(df_temp$full_name_MI[1], "_panel.png")
    ),
    format = "png"
  )
  index2 <- 1
  for (index2 in seq(1:nrow(df_temp))) {
    file.rename(
      from = here(blog_folder, photo_folder, match1, df_temp$photo_names[index2]),
      to = here(blog_folder, photo_folder, archive_folder, df_temp$photo_names[index2])
    )
  }
}
}

```

Look at these high multiples more closely.



https://stackoverflow.com/questions/61196196/image-append-on-dynamic-number-of-variables

```{r}

```

Now I need to redo everything so it will only match on the panel figures and not the ones I moved.



```{r}
photo_names_r1 = list.files(here(blog_folder, photo_folder, match1))
photo_df_MI_final = as.data.frame(photo_names_r1)
tombstones_matched <- fuzzy_right_join(photo_df_MI_final, tombstones, 
                             by = c("photo_names_r1" = "full_name_MI"),
                             match_fun = str_detect)
```

I think this produces one more than it should in photo names. 75 instead of 74 via code below vs looking at \# files in the folders. probably still this shared name hester & levi jones

```         
sum(!is.na(tombstones_matched$photo_names2))
```

## Matching Middle Names with no space.

(need to convert this column to nas above.)

Converting to NAs, (match on space vs. no space

```{r}
unmatched_middle <- tombstones_matched %>%
  mutate(full_name_MI_no_space = na_if(full_name_MI_no_space, " ")) %>%
  filter(is.na(full_name_MI_no_space) == FALSE) %>%
  filter(is.na(photo_names_r1) == TRUE)
   
```

Okay, 17 didn't match.

Make the photo list from the Problems folder. Should rename to unmatched.

```{r}
photo_names_r2 = list.files(here(blog_folder, photo_folder, unmatched_folder))
match_round2 = as.data.frame(photo_names_r2)
```

Now

```{r}
tombstones_matched2 <- fuzzy_right_join(match_round2, unmatched_middle, 
                             by = c("photo_names_r2" = "full_name_MI_no_space"),
                             match_fun = str_detect)
```

looks like we got all but three!

```{r}
multiples2 <- tombstones_matched2 %>% group_by(full_name_MI_no_space) %>% count(sort = TRUE) %>% filter(n > 1)
```

Now make panel pcis and move. Right now we need to be reading from problems.

```{r}
#testing
if (nrow(multiples2) > 0 ) {
index <- 1

for (index in seq(1:nrow(multiples2))) {
  df_temp <- tombstones_matched2 %>%
    filter(full_name_MI_no_space == multiples2$full_name_MI_no_space[index])
  df_temp
  these <-
    as.list(here(blog_folder, photo_folder, unmatched_folder, df_temp$photo_names_r2))
  photo_panel <-
    image_append(do.call("c", lapply(these, image_read)))
  image_write(
    photo_panel,
    path =  here(
      blog_folder,
      photo_folder,
      paste0(df_temp$full_name_MI_no_space[1], "_panel.png")
    ),
    format = "png"
  )
  index2 <- 1
  for (index2 in seq(1:nrow(df_temp))) {
    file.rename(
      from = here(blog_folder,photo_folder, unmatched_folder, df_temp$photo_names_r2[index2]),
      to = here(blog_folder, photo_folder, archive_folder, df_temp$photo_names_r2[index2])
    )
  }
}
}
```

I need to move the non-panel pictures I matched. **Where am I moving them?**

```{r}
 index2 <- 1
  for (index2 in seq(1:nrow(tombstones_matched2))) {
    if (is.na(tombstones_matched2$photo_names_r2[index2] ) == FALSE) {
    file.rename(
      from = here(blog_folder, photo_folder, tombstones_matched2$photo_names3[index2]),
      to = here(blog_folder, photo_folder, tombstones_matched2$photo_names_r2[index2])
    )
    }
  }
 
 

```

Now do the revised list for matched 2. Be careful when I copy and paste this because It is reading the whole folder and not just this round of matching so will catch the single letter names when I do later rounds, I think.

```{r}
photo_names4 = list.files(here(blog_folder, photo_folder))
photo_df_4 = as.data.frame(photo_names4)
tombstones_matched <- fuzzy_right_join(photo_df_4, tombstones, 
                             by = c("photo_names4" = "full_name_MI_no_space"),
                             match_fun = str_detect)
```

empty block

```{r}

```

# Converting to Geo Data

Dropping any NAs in lat/long. Converting it to a SF geo object. I'm adding some jitter to the coordinates; tombstones that are very close to each other have the same coordinates and show up as overlapping on the map.

```{r}
tombstones_final <- tombstones_final %>% drop_na(lat) %>% drop_na(long)


tombstones_geo <- st_as_sf(tombstones_merged, coords = c("long", "lat"), crs = 4326)
tombstones_geo <- st_jitter(tombstones_geo, factor = 0.001)


```

Final map.

```{r}
#| column: page
#| 
image_list <- tombstones_geo$photo_names

labels <- sprintf(
  "<strong>tombstones_geo$full_name</strong> <br/>,
  tombstones_geo$Cemetery" ) %>% lapply(htmltools::HTML)

leaflet() %>%
  addTiles() %>%
  #addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    data = tombstones_geo,
    label = ~ (paste( First.Name, Surname, "-", Cemetery, "Cemetery", sep = " ")), 
   # label = ~labels,
   # popup = leafpop::popupImage(paste0(here(blog_folder, photo_folder),"/", image_list)),
    clusterOptions = markerClusterOptions(),
    opacity = 1,
    radius = 10,
    color = "blue",
    stroke = NA,
    group = "group1"
  )  %>%

# popup = ~tag,


   leafpop::addPopupImages(
    image = paste0(here(blog_folder, photo_folder),"/", image_list),
     src = local,
     group = "group1", width = 600,
    maxHeight = 300, maxWidth = 600
   )

```
