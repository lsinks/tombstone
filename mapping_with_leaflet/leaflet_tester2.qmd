---
title: "Leaflet_tester"
date: 06-30-2023
categories: [Data-Viz, R, leaflet, quarto, problem solving, mapping, Code-Along] # self-defined categories
draft: true # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
---

# Project Overview

I'm working on a project for my father that will culminate in a website for his genealogy research. [There are a couple of different parts](https://lsinks.github.io/currentprojects.html) that I'm working on independently. In a previous part of the project, I matched an excel sheet with gps coordinates and some biographic data with photos of various tombstones. This part involves making a leaflet map of various family grave sites.

In this part, I'm going to show you how to create a nicely styled leaflet map. I will use the R package leaflet exclusively; while the package leaflet.extras has some nice features, the contributor stopped maintaining it in 2018 and [recommends against using it for security reasons](https://github.com/bhaskarvk/leaflet.extras#readme).

# Setting Up

## Loading Libraries

I'll include more info and reference information about the packages at the code blocks where I use them.

```{r}
#| label: loading-libraries
#| warning: false
#| output: false
library(tidyverse) # who doesn't want to be tidy?
library(gt) # For nice tables
library(sf) # for handling geo data
library(leaflet) # mapping
library(here) # reproducible file paths
#library(htmltools)
library(htmlwidgets)


```

## File Folder Names and Loading Data

Here set-up some variables that I use for the file/ folder structure and I read in the spreadsheet.

```{r}
#| label: reading-data
#| warning: false
#| output: false

# folder names
blog_folder <- "mapping_with_leaflet"
photo_folder <- "Map"
```

Reading in the data. This is data created by the previous portion of the project. There are also a bunch of photos in the Map folder. The specific photo that is associated with a given entry is listed in the photo_list column.

```{r}
tombstones_geo <- readRDS(here(blog_folder, "tombstones_geo.RDS"))
```

# About Leaflet

[Leaflet is a JavaScript library](https://leafletjs.com/index.html). The R package leaflet provides an interface to many of the core leaflet features. The options for leaflet maps are endless; the R package documentation is a high level overview and delving into the JavaScript documentation for details is a must if you want to do a lot of customizations. You can also extend R leaflet by calling [JavaScript plugins within R leaflet](http://rstudio.github.io/leaflet/extending.html). This is beyond the scope of this tutorial. Since the number of plugins/libraries/extensions for leaflet in JavaScript is extensive, it is worth being aware of this option.

Here, I'm going to stick with features available in the R leaflet package, though I will pass some options that I found in the JavaScript documentation.

# Handling Overlapping Points?

Some tombstones are very close together and have the same gps coordinates. I initially solved this by using sf_jitter() to jitter the coordinates, but I didn't optimize it at all. Here I'm going to demonstrate a few different ways to handle this issue.

First, how many overlapping points do I have?

```{r}
#| label: table-duplicate-geos
test <-
  tombstones_geo %>% 
  group_by(geometry) %>% 
  count(geometry, sort = TRUE) %>% 
  filter(n > 1)

test %>% gt() %>% 
  tab_options(container.height = px(300), container.padding.y = px(24))
```

27 sets of identical coordinates.

Now let's make a set of entries that are only duplicates. To join spatial data, we need to use st_join. The type of join is set with the parameter left. If left = TRUE then the function returns a left join, otherwise, and inner_join. This function defaults to TRUE according to the documentation, but it seems that whether left is set to TRUE or FALSE, it returns the inner join.

Join type defaults to intersect. **More BLAH**

```{r}
#| label: spatial-join
test_for_jitter_left <- tombstones_geo %>% st_join(test, left = TRUE) %>% filter(n>1)

test_for_jitter_inner <- tombstones_geo %>% st_join(test, left = FALSE) %>% filter(n>1)

identical(test_for_jitter_left, test_for_jitter_inner)
```

# Building a Simple Map

I'm going work on this problem using the one set of coordinate where there are 3 tombstones.

```{r}
#| label: site-with-three-graves
test <- test_for_jitter_inner %>%
  filter(n == 3)
```

Here is the simplest leafelt map we can make. The procedure is to intialize leaflet, add an underlying map (add_Tiles) and then add my markers with the label (addCircleMarkers) from my dataframe. The layerID is so we can remove this object later.

## Default Map

```{r}
#| label: default-leaflet-map

simple_map <- leaflet() %>%
  addTiles() %>%
  addScaleBar() %>%
  addCircleMarkers(data = test,
                   label = ~ (paste(complete_name, cemetery_name, sep = " ")))
simple_map
```

The idea choice would be to "spiderify" this map. Spiderifying disperses the points as you zoom in (as we will see with the clustering option). [Leaflet is a JavaScript library](https://leafletjs.com/index.html). Some of the features and extras have been ported to the R package [leaflet.extras](https://bhaskarvk.github.io/leaflet.extras/), but [spiderifying isnt'](https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet/issues/36). The module for spiderifying in javascript can be found [here](https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet). (The [demo is awesome](http://jawj.github.io/OverlappingMarkerSpiderfier-Leaflet/demo.html) and that is exactly what I want!)

# MarkerCluster Map

Now, MarkerCluster does include spiderifying. I'm going to go back to the 55 datapoints set just to illustrate the clustering more clearly

```{r}
#| label: markercluster-map
cluster_map <- leaflet() %>%
  addTiles() %>%
  addScaleBar() %>%
  addCircleMarkers(
    data = test,
    label = ~ (paste(complete_name, cemetery_name, sep = " ")), 
    clusterOptions = markerClusterOptions(),
    )

cluster_map
    
```

(You can't have a layerId with clustering?)

It does separate the points, but it is very hard to click on correct portion of the dot to get the label or pop-up. I think you need to hover on the part of the circle marker that does not overlap with either the cluster marker or the or the other circle markers. This can be solved by making the circle markers very large, so there is more non-overlapping area, but this is ugly. It turns out you can also set the spiderfying distance for the markerCluster. Documentation is back in the [js library](https://github.com/Leaflet/Leaflet.markercluster#other-options).

```{r}
#| label: markercluster-map-more-spiderified
#| column: page


cluster_map_separated <- leaflet() %>%
  addTiles() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addScaleBar() %>%
  addCircleMarkers(
    data = test,
    label = ~ (paste(complete_name, cemetery_name, sep = " ")), 
    clusterOptions = markerClusterOptions(spiderfyDistanceMultiplier= 2)
  ) 

cluster_map_separated
```

## Using sf_jitter

So, now back at st_jitter

**amount**

:   numeric; amount of jittering applied; if missing, the amount is set to factor \* the bounding box diagonal; units of coordinates.

**factor**

:   numeric; fractional amount of jittering to be applied

(also can't use layer ID)

:   doesn't work on a single set?

```{r}
#| label: map-spatial-jitter-small

test_jittered <- test %>%
  st_jitter( factor = 0.00001)

map_sf_jitter_one <- leaflet() %>%
  addTiles() %>%
  addScaleBar() %>%
  addCircleMarkers(
    data = test_jittered,
    label = ~ (paste(complete_name, cemetery_name, sep = " "))
  ) 

map_sf_jitter_one
```

Does work on a the whole test set.

```{r}
#| label: map-spatial-jitter-large
test_jittered_all <- test_for_jitter_inner %>%
  st_jitter( factor = 0.00001)

map_sf_jitter_all <- leaflet() %>%
  addTiles() %>%
  addScaleBar() %>%
  addCircleMarkers(
    data = test_jittered_all,
    label = ~ (paste(complete_name, cemetery_name, sep = " ")),radius = 10,
    stroke = NA
  ) 

map_sf_jitter_all
```

This works ok, but the zooming experience is very unpleasent. With the clustered option, the map is zoomed and centered as you click through the clusters. There is also a very clear indication (the number in the cluster) that there are mutiple data points in the dot. Here, more datapoints make a darker circle, but this isn't crystal clear.

# Styling the Clustered Map

So, I'm going to go with the clustered version. I can have additional information in layers. There are 70+ different cemeteries, so I don't want to have 70+ layers.

I could use era or surname as a layer option. There are 65 different surnames. That still feels like too much.

```{r}
#| label: number-surnames
tombstones_geo %>% group_by(Surname) %>% count(sort = TRUE)
```

Make a nice label formatted with HTML

```{r}
#| label: html-formating-info-box
tombstones_geo <- tombstones_geo %>%
    mutate(boxinfo = paste0(
      '<strong>',  complete_name ,'</strong>',
      '<br/><hr>',
       DOB, ' ', DOD,
      '<br/><hr>',
      
     '<strong>',  cemetery_name ,'</strong>',
      '<br/><hr>',
       City, ' ', State,
    
      '<br/>'
      )%>% 
  lapply(htmltools::HTML)
  )



#labels <- sprintf(
#  "<strong>%s</strong><br/>%g people / mi<sup>2</sup>",
#  states$name, states$density
#) %>% 
#  lapply(htmltools::HTML)
```

tombstones_geo \<- tombstones_geo %\>%

mutate(boxinfo = paste0(

'\<strong\>Name:\</strong\>',

complete_name,

'\<br/\>\<hr\>',

'\<strong\>Cemetery:\</strong\>',

Cemetery,

'\<br/\>'

)%\>%

lapply(htmltools::HTML)

)

# Back to clustering

Click on a cluster. It will zoom and split the point as you keep clicking until you end up with just the points with the same coordinated.

```{r}
#| label: final-cluster-map
#| column: page
image_list <- tombstones_geo$photo_list
final_map <- leaflet() %>%
  addTiles() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addScaleBar() %>%
  addCircleMarkers(
    data = tombstones_geo,
    label = ~ (paste(complete_name, cemetery_name, sep = " ")),
    popup = ~boxinfo,
    clusterOptions = markerClusterOptions(spiderfyDistanceMultiplier= 2, maxClusterRadius = 30),
    radius = 10,
    stroke = NA,
    group = "group1"
  )%>%
  leafpop::addPopupImages(
     image = paste0(here(blog_folder, photo_folder),"/", image_list),
       src = local,
      group = "group1", width = 400,
   maxHeight = 300, maxWidth = 400
    )
```

```{r}
#| label: viewing-final-map
final_map
```

```{r}
#| label: saving-map
#library(htmlwidgets)
saveWidget(final_map, file ="map_to_upload.html")
```

# Conclusions
